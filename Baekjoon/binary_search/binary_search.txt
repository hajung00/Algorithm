1. 순차 탐색 vs 이진 탐색

ex) 리스트에서 값이 12인 원소 위치 찾기
0 2 4 6 8 10 12 14 16 18

1) 순차 탐색
- 리스트 안에 있는 특정한 데이터를 찾기 위해 앞에서부터 하나씩 확인
- 위의 리스트에서는 12인 원소를 찾기 위해 0->2->4->6->...->18까지 하나씩 확인
- 시간 복잡도 O(N)

2) 이진 탐색
- 정렬되어 있는 리스트에서 탐색 범위를 절반씩 좁혀가며 데이터 탐색
0 2 4 6 8 10 12 14 16 18
*       ^              *
          *     ^      *
          *^ *
             *^*
*: 왼쪽(left), 오른쪽(right)
^: 왼쪽, 오른쪽의 가운데 값(내림)
- 왼쪽 0과 오른쪽 18의 가운데 8과 찾으려는 원소 12의 값 비교 -> 12가 8보다 크므로 mid+1값을 left로 설정
 -> 왼쪽 10과 오른쪽 18의 가운데 14와 원소 12의 값 비교 -> 12가 14보다 작으므로 mid-1값을 right로 설정
 -> left가 right보다 작을 경우에 반복

- 시간 복잡도 O(logN)

2-1) 이진 탐색의 대표적 사례
- 매우 넓은 탐색 범위에서 최적의 해를 찾아야 하는 경우
- 데이터를 정렬한 뒤에 다수의 쿼리를 날려야 하는 경우

2. 정렬된 배열에서 특정 원소의 개수 구하기

- 정렬된 배열에서 특정 원소의 개수 구하기 위해서 lowerBound()함수와 upperBound()함수를 사용할 수 있다.

*lowerBound(arr, x): 정렬된 순서를 유지하면서 배열 arr에 x를 넣을 가장 왼쪽 인덱스를 반환
*upperBound(arr, x): 정렬된 순서를 유지하면서 배열 arr에 x를 넣을 가장 오른쪽 인덱스를 반환

ex) 리스트에서 값이 5인 원소 개수 찾기 
3 4 5 5 5 7 9 

lowerBound(arr, 5): 2
upperBound(arr, 5): 5

원소 개수: upperBound(arr, 5) - lowerBound(arr, 5)